---
title: "Analyzing metrics of ecological specialization"
output: html_document
---

**Goal:**

Assess whether hummingbirds rewired to use alternative resources after Heliconia removal

If hummingbirds rewired, then ecological specialization should decrease at multiple levels (i.e., network, species, and individual). This would be indicated by:

- an increase in niche breadth (i.e., a *DECREASE* in the Species Specificity Index)
- a corresponding increase in niche overlap (i.e., a *DECREASE* in reciprocal specialization measured by H2 and d')
- an *INCREASE* in the number of pollen morphotypes per hummingbird

**Approach**

For all response variables, will text for treatment effect using a statistical interaction between control/treatment and experimental period (pre/post).

1. Network metrics (H2, d', SSI)

- Values range from 0-1
- Will analyze using GLMMs (beta regression)
- Network-level specialization = H2
- Species-level specialization = mean d', mean SSI
  * I'll analyze for each hummingbird group: all species and *Heliconia* specialists (green hermits & violet sabrewings) separately

2. Number of pollen morphotypes

- Values range from 1-8, since birds with no pollen have already been removed
- Will analyze using GLMMs (truncated Poisson or similar count distribution; will choose most appropriate distribution based on AICc)
- I'll analyze for each hummingbird group: all species and *Heliconia* specialists (green hermits & violet sabrewings) separately
- I'll also analyze recaps separately from all of the individual birds captured. Here, "recap" = bird caught during the pre AND the post period


```{r setup, include = FALSE}
library(tidyr)
library(dplyr)
library(purrr)
library(glmmTMB)
library(DHARMa)
library(ggplot2)
library(ggpubr)
library(emmeans)
library(ggeffects)
```

## Step 1: Import functions and datasets for analysis

**Custom functions**
```{r step1a}
source("../scripts/helper_functions/Transform_proportion_for_betareg.R")
source("../scripts/helper_functions/Extract_data_from_safely_and_quietly_lists.R")
source("../scripts/helper_functions/Modeling_helper_functions.R")
source("../scripts/helper_functions/Plotting_helper_functions.R")
```

Network metrics were calculated in script #04 and pollen richness (# morphotypes/bird) was calculated in script #02.

**Get network metrics** (pollen and camera)
```{r step1b, message = FALSE}
#Get data + remove replicates than don't have a complete pre-post pair
network_data_import <- read.csv("../data/export/for_analysis/Network_specialization_for_analysis.csv") %>%
  mutate(year_patch = paste(year, patch, sep = "_")) %>%
  select(sampling_method, bird_group, year, year_patch, everything(), -X) %>%
  filter(is.na(unpaired))

#Transform response variable for analysis
#Also remove highly influential points (2016_60, 2018_60) - both of these networks have compartments of species entirely unconnected to rest of network
network_data <- network_data_import %>%
  group_by(sampling_method, bird_group, metric, control_treatment, exp_phase) %>%
  mutate(value_transform = transform_proportion(value)) %>%
  ungroup() %>%
  mutate(exp_phase = factor(exp_phase, levels = c("pre", "post"))) %>%
  filter(year_patch != "2016_60") %>%
  filter(year_patch != "2018_60")
```

**Get richness data** (i.e., individual specialization, pollen only)
```{r step1c, message = FALSE}
#Get data
richness_data_import <- read.csv("../data/export/for_analysis/Pollen_data_summarized_for_pp_richness.csv") %>%
  select(-X) %>%
  mutate(year_patch = paste(year, patch, sep = "_"))

#Remove replicates than don't have a complete pre-post pair
#Note: by definition, recaps are present pre and post, so if there's a recap then the replciate is automatically considered 'complete'
unpaired_replicates <- richness_data_import %>%
  distinct(year, patch, year_patch, exp_phase) %>%
  group_by(year, patch, year_patch) %>%
  summarise(num_phases = n()) %>%
  ungroup() %>%
  filter(num_phases < 2) %>%
  mutate(include = "no")

#Complete replicates only for analysis
richness_data <- richness_data_import %>%
  left_join(unpaired_replicates) %>%
  filter(is.na(include)) %>%
  select(year, patch, year_patch, everything(), -include, -num_phases) %>%
  mutate(exp_phase = factor(exp_phase, levels = c("capture_1", "capture_2"), labels = c("pre", "post")))
```

## Step 2: Get organized

**Get organized**

Since I'll have quite a few models, I want to store them all in tibbles to stay organized
```{r step2a, message = FALSE}
bird_groups <- c("all_spp", "greh_visa")

analysis_network <- c("pollen", "visitation")
yvars_network <- c("H2", "d", "species.specificity.index")
yvars_names_network <- data.frame(yvars_network = yvars_network, yvars_names = c("H2'", "d'", "Species Specificity Index"))

analysis_richness <- c("pollen_recaps", "pollen_all_birds")
yvars_richness <- c("num_morphotypes")
yvars_names_richness = data.frame(yvars_richness = yvars_richness, yvars_names = c("Number of morphotypes"))

#Make table for network analyses
#Need to remove H2 model for GREH/VISA, because H2 is not a species-level metric
base_table_network <- crossing(analysis_network, bird_groups, yvars_network) %>% 
  left_join(yvars_names_network) %>%
  rename(analysis = analysis_network, yvars = yvars_network) %>%
  filter(!(yvars == "H2" & bird_groups == "greh_visa")) %>%
  mutate(model_number = 1:length(analysis)) %>%
  mutate(model_id = paste(model_number, "network", sep = "_")) %>%
  mutate(title = paste(analysis, bird_groups, sep = "_")) %>%
  mutate(subtitle = yvars)
           
#Make table for richness analyses
base_table_richness <- crossing(analysis_richness, bird_groups, yvars_richness) %>% 
  left_join(yvars_names_richness) %>%
  rename(analysis = analysis_richness, yvars = yvars_richness) %>%
  mutate(model_number = 1:length(analysis)) %>%
  mutate(model_id = paste(model_number, "individual", sep = "_")) %>%
  mutate(title = paste(analysis, bird_groups, sep = "_")) %>%
  mutate(subtitle = yvars)
```

**Create function to subset data for each model of interest**
```{r step2b, message = FALSE}
#Function to subset data for each model of interest
subset_data <- function(dataset, analysis, bird_group, yvar){
  
  #Individual specialization (# pollen morphotypes/bird)
  if(yvar == "num_morphotypes"){
    
    #Hummingbird group of interest
    if(bird_group == "greh_visa"){dataset <- dataset %>% filter(bird_species == "GREH" | bird_species == "VISA")}

    #Recap or not
    if(analysis == "pollen_recaps"){dataset <- dataset %>% filter(recap_y_n == "yes")}
    
  }
  
  #Species- and network-level specialization (H2, d, SSI)
  if(yvar != "num_morphotypes"){
    
     #Sampling method
    if(analysis == "pollen"){dataset <- dataset %>% filter(sampling_method == "pollen")}
    if(analysis == "visitation"){dataset <- dataset %>% filter(sampling_method == "visitation")}

    #Hummingbird group of interest
    if(bird_group == "all_spp"){dataset <- dataset %>% filter(bird_group == "all_spp")}
    if(bird_group == "greh_visa"){dataset <- dataset %>% filter(bird_group == "greh_visa")}
  
    #Response variable
    if(yvar == "H2"){dataset <- dataset %>% filter(metric == "H2")}
    if(yvar == "d"){dataset <- dataset %>% filter(metric == "d")}
    if(yvar == "species.specificity.index"){dataset <- dataset %>% filter(metric == "species.specificity.index")}
    
  }
  
  return(dataset)
  
}

#Functions to create models
#Default optimizer is nlminb; if convergence issues try alternative optimizer:
#control=glmmTMBControl(optimizer=optim, optArgs=list(method="BFGS"))
#If use eval(bquote(.(stuff you don't want quoted))), won't have garbled formula
create_model <- function(dataset, yvar){
  
  #Individual specialization (# pollen morphotypes/bird)
  if(yvar == "num_morphotypes"){
    
    model <- eval(bquote(glmmTMB(.(as.formula(paste(yvar, "~ control_treatment * exp_phase + (1|patch/year_patch)"))), data = dataset, na.action = na.omit, family = "truncated_genpois", control = glmmTMBControl(optimizer=optim, optArgs=list(method="BFGS")))))

  }
  
  #Species- and network-level specialization (H2, d, SSI)
  if(yvar != "num_morphotypes"){
    
    model <- eval(bquote(glmmTMB(.(as.formula(paste(yvar, "~ control_treatment * exp_phase + (1|patch/year_patch)"))), data = dataset, na.action = na.omit, family = "beta_family")))

  }
  
  return(model)
  
}
```

```{r step2c, include = FALSE, eval = FALSE}
#Testing functions created in previous step
#Datasets
test_data01 <- subset_data(dataset = network_data, analysis = "pollen", bird_group = "all_spp", yvar = "H2")
test_data02 <- subset_data(dataset = network_data, analysis = "visitation", bird_group = "all_spp", yvar = "H2")

test_data03 <- subset_data(dataset = richness_data, analysis = "recap", bird_group = "all_spp", yvar = "num_morphotypes")
test_data04 <- subset_data(dataset = richness_data, analysis = "recap", bird_group = "greh_visa", yvar = "num_morphotypes")

test_data05 <- subset_data(dataset = richness_data, analysis = "all_birds", bird_group = "all_spp", yvar = "num_morphotypes")
test_data06 <- subset_data(dataset = richness_data, analysis = "all_birds", bird_group = "greh_visa", yvar = "num_morphotypes")

#Models
test_model01 <- create_model_network(dataset = test_data01, yvar = "value_transform")

#Predictor variables
test_xvars01 <- data.frame(xvar = all.vars(terms(test_model01))[-1])
test_xvars01
```

## Step 3: Analyze network metrics

**Create models**
```{r step3a, message = FALSE}
models_network <- base_table_network %>%
  mutate(data = pmap(list(analysis, bird_groups, yvars), ~subset_data(dataset = network_data, analysis = ..1, bird_group = ..2, yvar = ..3))) %>%
  mutate(model_quietly = pmap(list(data), quietly(function(a){model <- create_model(dataset = a, yvar = "value_transform")})),
         model = map(model_quietly, get_result),
         warning = map(model_quietly, get_warning), 
         convergence = map(model, check_convergence)) %>%
  mutate(xvar_table = map(model, ~data.frame(xvar = all.vars(terms(.))[-1])))

#Make sure there weren't any problems + check to make sure table of predictor variables is correct
# models_network$warning
# models_network$convergence
# models_network$xvar_table
```

**Check assumptions**
```{r step3b, message = FALSE, fig.show = 'hide', results = 'hide'}
assumption_checks_network <- models_network %>%
  mutate(re_plot = pmap(list(model, title, subtitle), ~check_re(model = ..1, plot_title = ..2, plot_subtitle = ..3))) %>%
  mutate(dharma_object = map(model,
                             ~simulateResiduals(fittedModel = ., n = 1000, plot = FALSE, re.form = ~0))) %>%
  mutate(dharma_plot_safely = pmap(list(dharma_object, title, subtitle),
                                   safely(function(a, b, c){make_dharma_plot(dharma_object = a, plot_title = b, plot_subtitle = c, plot_type = "basic")})),
         dharma_plot = map(dharma_plot_safely, get_result)) %>%
  mutate(dharma_xvar_plot = pmap(list(xvar_table, data, dharma_object, title, subtitle),
                                 ~make_dharma_xvar_plot(predictor_table = ..1, dataset = ..2, dharma_object = ..3, plot_title = ..4, plot_subtitle = ..5))) %>%
  mutate(plotname1 = paste("re_diagnostics_", model_id, ".png", sep = "")) %>%
  mutate(plotname2 = paste("dharma_overall_diagnostics_", model_id, ".png", sep = "")) %>%
  mutate(plotname3 = paste("dharma_xvar_diagnostics_", model_id, ".png", sep = ""))
         
#For some reason, this first model throws an error when making the DHARMa plot: x missing value where TRUE/FALSE needed
#The error seems to be for quantile regression that gives the lines on the resid vs. predicted plot
#Except for missing the quantile regression lines, the plot looks OK though
# models_network$model[[5]] %>% DHARMa::simulateResiduals() %>% plot()

#Export diagnostic plots because they load very slowly in RStudio
setwd("../results/analyses_experiment/assumption_checks/network_species_specialization")
walk2(assumption_checks_network$plotname1, assumption_checks_network$re_plot, ~ggsave(filename = .x, plot = .y, height = 11.5, width = 15, units = "in", bg = "white"))
walk2(assumption_checks_network$plotname3, assumption_checks_network$dharma_xvar_plot, ~ggsave(filename = .x, plot = .y, height = 11.5, width = 15, units = "in"))

#Remove problematic plot before trying to export DHARMa plots
assumption_checks_network <- assumption_checks_network %>% filter(model_number != "5")
walk2(assumption_checks_network$plotname2, assumption_checks_network$dharma_plot, ~ggsave(filename = .x, plot = .y, height = 11.5, width = 15, units = "in"))
```

**Create model summaries, calculate confidence intervals, and tidy results into dataframe for export**
```{r step3c, message = FALSE}
#Will also add information about sample size: total # of observations (rows), number of levels per random effect, and the number of replicates (split into 'control' vs. 'treatment')
results_network <- models_network %>%
  mutate(summary = map(model, summary),
         summary_tidy = map(model, broom.mixed::tidy),
         confint_wald = map(model, ~calculate_ci(., method_name = "wald"))) %>%
  mutate(num_obs = map(model, get_number_obs),
         num_levels = map(model, get_number_re_levels),
         num_reps = map(data, ~get_sample_size(data = ., vars = c("year", "patch", "control_treatment"), grouping_var = "control_treatment")))

#Extract model summaries
results_tidy_network <- results_network %>%
  select(model_number, analysis, bird_groups, yvars, summary_tidy) %>%
  unnest(c(summary_tidy))

#Extract confidence intervals
results_confint_network <- results_network %>%
  select(model_number, analysis, bird_groups, yvars, confint_wald) %>%
  mutate(confint_df = map(confint_wald, as.data.frame)) %>% #CI as dataframe
  mutate(confint_df = map(confint_df, ~tibble::rownames_to_column(., var = "term"))) %>%
  unnest(cols = confint_df) %>%
  rename(lowerCI = "2.5 %", upperCI = "97.5 %") %>%
  select(-confint_wald, -Estimate)

#Back-transform coefficients and confidence intervals to data scale from model scale
results_tidy_confint_network <- results_tidy_network %>%
  left_join(results_confint_network) %>%
  mutate_at(vars(estimate, lowerCI, upperCI), .funs = list(exp = ~ifelse(effect == "fixed", exp(.), NA))) %>% 
  mutate_at(vars(estimate, std.error, statistic, lowerCI, upperCI, estimate_exp, lowerCI_exp, upperCI_exp), ~round(., digits = 2)) %>%
  mutate(pvalue_round = format.pval(pv = p.value, digits = 2, eps = 0.001)) %>%
  select(model_number:term, estimate, lowerCI, upperCI, statistic, pvalue_round, pvalue = p.value, std_error = std.error, everything())

#Extract number of reps for each dataset
sample_size_network <- results_network %>%
  select(model_number, analysis, bird_groups, yvars, num_obs, num_reps) %>%
  unnest(cols = num_reps) %>%
  mutate(num_obs = unlist(num_obs))
```

**Calculate estimated marginal means, control and treatment contrasts, and contrast of contrasts**

Control and treatment contrasts = pre-to-post change in control replicates *AND* pre-to-post change in treatment replicates (calculated separately)

Contrast of contrasts = pre-to-post change in control replicates *RELATIVE TO* pre-to-post change in treatment replicates. This is the contrast reflecting the treatment:phase interaction term.

```{r step3d, message = FALSE}
#Calculate estimated means (for plots), pre-to-post contrasts (for written results interpretation), and contrast of contrasts (for plots)
emmeans_contrasts_network <- results_network %>%
  mutate(ggeffects = map(model, ~ggemmeans(., terms = c("exp_phase", "control_treatment"), back.transform = TRUE))) %>%
  mutate(emm = map(model, ~emmeans(., specs = ~exp_phase:control_treatment))) %>%
  mutate(emm_contrasts = map(emm, ~contrast(., method = "revpairwise", by = c("control_treatment"), type = "response"))) %>%
  mutate(emm_contrasts_x2 = map(emm, ~contrast(emmeans(., ~exp_phase:control_treatment), interaction = ("revpairwise"), type = "response")))
  
#Extract estimated marginal means 
emmeans_network <- emmeans_contrasts_network %>%
  select(model_number, analysis, bird_groups, yvars, ggeffects) %>% 
  unnest(cols = c(ggeffects))

#Extract contrasts (first need to convert into dataframe)
contrasts_network <- emmeans_contrasts_network %>%
  mutate(emm_contrasts = map(emm_contrasts, ~as.data.frame(summary(., infer = TRUE)))) %>%
  select(model_number, analysis, bird_groups, yvars, emm_contrasts) %>% 
  unnest(cols = c(emm_contrasts)) %>%
  select(model_number, analysis, bird_groups, yvars, contrast, control_treatment, odds.ratio, lowerCI = lower.CL, upperCI = upper.CL, std_error = SE, everything()) %>%
  mutate_if(is.numeric, ~round(., digits = 2))

#Extract contrast of contrasts (first need to convert into dataframe)
contrasts_x2_network <- emmeans_contrasts_network %>%
  mutate(emm_contrasts_x2 = map(emm_contrasts_x2, ~as.data.frame(summary(., infer = TRUE)))) %>%
  select(model_number, analysis, bird_groups, yvars, emm_contrasts_x2) %>% 
  unnest(cols = c(emm_contrasts_x2)) %>%
  select(model_number, analysis, bird_groups, yvars, contains("revpairwise"), odds.ratio, lowerCI = lower.CL, upperCI = upper.CL, std_error = SE, everything()) %>%
  mutate_if(is.numeric, ~round(., digits = 2))
```

**Plot results**

There are two ways that I like to visualize the interaction term of interest

1. Interaction plots, with estimated marginal means for control/treatment and pre/post (pre and post values connected by lines)

- These interaction plots can be confusing without detailed explanation, so I will put them in the supplemental information.

2. Contrast plots, with contrast reflecting the interaction term and its associated confidence intervals

- These are the key plots for the main text. I will combine all specialization analyses - network, species, and individual-level - into one figure.

Interaction plots
```{r step3e, message = FALSE, fig.width=9, fig.height=12}
interaction_plots_network <- emmeans_contrasts_network %>%
  mutate(interaction_plot = pmap(list(ggeffects, yvars), ~make_interaction_plot(ggeffects_df = ..1, yvar = ..2, ymax = 0.8))) %>%
  mutate(yvars = factor(yvars, levels = c("H2", "d", "species.specificity.index")))

#Make multiplot (ALL SPECIES)
interaction_plots_network_all <- interaction_plots_network %>%
  filter(bird_groups == "all_spp") %>%
  arrange(yvars, analysis)

interaction_multiplot_network_all <- ggarrange(plotlist = interaction_plots_network_all$interaction_plot, nrow = 3, ncol = 2, common.legend = TRUE, legend = "bottom")
interaction_multiplot_network_all
```

```{r step 3f, fig.width=9, fig.height=9}
#Make multiplot (GREH/VISA)
interaction_plots_network_gv <- interaction_plots_network %>%
  filter(bird_groups == "greh_visa") %>%
  arrange(yvars, analysis)

interaction_multiplot_network_gv <- ggarrange(plotlist = interaction_plots_network_gv$interaction_plot, nrow = 2, ncol = 2, common.legend = TRUE, legend = "bottom")
interaction_multiplot_network_gv
```

Contrast plot
```{r step3g, message = FALSE}
h2_label <- c(expression(atop(paste(italic(H[2])*"'"))))
d_label <-  c(expression(atop(paste("mean "*italic(d)*"'"))))
ssi_label <- c(expression(atop(paste("mean SSI"))))

#Contrast plot (POLLEN)
contrast_plot_pollen <- contrasts_x2_network %>%
  filter(analysis == "pollen") %>%
  make_contrast_plot(estimate_name = "odds.ratio", xaxis_name = "yvars", shading = "below") +
  scale_x_discrete("Specialization", labels = c(h2_label, d_label, ssi_label)) +
  scale_y_continuous(limits = c(0, 6), breaks = c(0, 0.5, 1, 2, 3, 4, 5, 6)) +
  coord_cartesian(ylim = c(0, 6), xlim = c(1, 3), clip = "off") +
  theme(plot.margin = unit(c(0, 0, 0.5, 3), "in"))  #Default plot margins in theme_bw are 1, 1, 0.5, 0.5 (top, right, bottom, left)

#Contrast plot (VISITATION)
contrast_plot_visitation <- contrasts_x2_network %>%
  filter(analysis == "visitation") %>%
  make_contrast_plot(estimate_name = "odds.ratio", xaxis_name = "yvars", shading = "below") +
  scale_x_discrete("Specialization", labels = c(h2_label, d_label, ssi_label)) +
  scale_y_continuous(limits = c(0, 6), breaks = c(0, 0.5, 1, 2, 3, 4, 5, 6)) +
  coord_cartesian(ylim = c(0, 6), xlim = c(1, 3), clip = "off") +
  labs(y = "") +
  theme(plot.margin = unit(c(0, 3, 0.5, 0), "in")) + #Default plot margins in theme_bw are 1, 1, 0.5, 0.5 (top, right, bottom, left)
  annotate("segment", x = 4, xend = 4, y = 1.25, yend = 3, col="black", size = 1, arrow = arrow(length = unit(0.3, "cm"))) +
  annotate("segment", x = 4, xend = 4, y = 0.75, yend = 0, col="black", size = 1, arrow = arrow(length = unit(0.3, "cm"))) +
  annotate("text",  x = 5.5, y = 2, size = 4, angle = 0, color = "black", label = c("Pre-to-post increase\nrelative to controls")) +
  annotate("text",  x = 5.5, y = 0.5, size = 4, angle = 0, color = "black", label = c("Pre-to-post decrease\nrelative to controls"))

#Contrast plot (POLLEN + VISITATION)
contrast_multiplot_network <- ggarrange(contrast_plot_pollen, contrast_plot_visitation, ncol = 2, align = "h", common.legend = TRUE, legend = c("top"))
```

## Step 4: Analyze pollen richness

Here, there are several count distributions that might work. I know that distribution should be truncated, since there are no zeroes, but I will use AICc to choose between Poisson, negative binomial, and generalized Poisson. 

**Choose distribution**
```{r step4a, message = FALSE, fig.show = 'hide', results = 'hide'}
#Get datasets for each model
data_richness <- base_table_richness %>%
  mutate(data = pmap(list(analysis, bird_groups, yvars), ~subset_data(dataset = richness_data, analysis = ..1, bird_group = ..2, yvar = ..3))) 

#Make candidate models and compare them. Convergence issues with default optimizer
m1 <- glmmTMB(num_morphotypes ~ control_treatment * exp_phase + (1|patch/year_patch), data = data_richness$data[[1]], na.action = na.omit, family = "truncated_poisson", control = glmmTMBControl(optimizer=optim, optArgs=list(method="BFGS")))
m2 <- glmmTMB(num_morphotypes ~ control_treatment * exp_phase + (1|patch/year_patch), data = data_richness$data[[1]], na.action = na.omit, family = "truncated_nbinom1", control = glmmTMBControl(optimizer=optim, optArgs=list(method="BFGS")))
m3 <- glmmTMB(num_morphotypes ~ control_treatment * exp_phase + (1|patch/year_patch), data = data_richness$data[[1]], na.action = na.omit, family = "truncated_nbinom2", control = glmmTMBControl(optimizer=optim, optArgs=list(method="BFGS")))
m4 <- glmmTMB(num_morphotypes ~ control_treatment * exp_phase + (1|patch/year_patch), data = data_richness$data[[1]], na.action = na.omit, family = "truncated_genpois", control = glmmTMBControl(optimizer=optim, optArgs=list(method="BFGS")))

model_fitting <- tibble(model_name = c("m1", "m2", "m3", "m4"), model = list(m1, m2, m3, m4)) %>%
  mutate(dharma_object = map(model, ~simulateResiduals(fittedModel = ., n = 1000, plot = FALSE, re.form = ~0))) %>%
  mutate(dharma_plot = pmap(list(dharma_object, model_name), ~make_dharma_plot(dharma_object = ..1, plot_title = ..2,  plot_type = "basic")),
         dharma_zeroinfl_plot = pmap(list(dharma_object, model_name), ~make_dharma_plot(dharma_object = ..1, plot_title = ..2,  plot_type = "zeroinflation")),
         dharma_overdisp_plot = pmap(list(dharma_object, model_name), ~make_dharma_plot(dharma_object = ..1, plot_title = ..2,  plot_type = "overdispersion"))) %>%
  mutate(AICc = map(model, MuMIn::AICc))
  
#AICc
model_fitting %>%
  select(model_name, AICc) %>%
  unnest(AICc) %>%
  arrange(AICc)

#Truncated generalized Poisson has lowest AICc. Added this function to 'create_model' function in earlier step
```

**Create models**
```{r step4b, message = FALSE}
models_richness <- data_richness %>%
  mutate(model_quietly = pmap(list(data), quietly(function(a){model <- create_model(dataset = a, yvar = "num_morphotypes")})),
         model = map(model_quietly, get_result),
         warning = map(model_quietly, get_warning), 
         convergence = map(model, check_convergence)) %>%
  mutate(xvar_table = map(model, ~data.frame(xvar = all.vars(terms(.))[-1])))

#Make sure there weren't any problems + check to make sure table of predictor variables is correct
# models_richness$warning
# models_richness$convergence
# models_richness$xvar_table
```

**Check assumptions**
```{r step4c, message = FALSE, fig.show = 'hide', results = 'hide'}
assumption_checks_richness <- models_richness %>%
  mutate(re_plot = pmap(list(model, title, subtitle), ~check_re(model = ..1, plot_title = ..2, plot_subtitle = ..3))) %>%
  mutate(dharma_object = map(model,
                             ~simulateResiduals(fittedModel = ., n = 1000, plot = FALSE, re.form = ~0))) %>%
  mutate(dharma_plot_safely = pmap(list(dharma_object, title, subtitle),
                                   safely(function(a, b, c){make_dharma_plot(dharma_object = a, plot_title = b, plot_subtitle = c, plot_type = "basic")})),
         dharma_plot = map(dharma_plot_safely, get_result)) %>%
  mutate(dharma_xvar_plot = pmap(list(xvar_table, data, dharma_object, title, subtitle),
                                 ~make_dharma_xvar_plot(predictor_table = ..1, dataset = ..2, dharma_object = ..3, plot_title = ..4, plot_subtitle = ..5))) %>%
  mutate(plotname1 = paste("re_diagnostics_", model_id, ".png", sep = "")) %>%
  mutate(plotname2 = paste("dharma_overall_diagnostics_", model_id, ".png", sep = "")) %>%
  mutate(plotname3 = paste("dharma_xvar_diagnostics_", model_id, ".png", sep = ""))
        
#Export diagnostic plots because they load very slowly in RStudio
setwd("../results/analyses_experiment/assumption_checks/individual_specialization")
walk2(assumption_checks_richness$plotname1, assumption_checks_richness$re_plot, ~ggsave(filename = .x, plot = .y, height = 11.5, width = 15, units = "in", bg = "white"))
walk2(assumption_checks_richness$plotname2, assumption_checks_richness$dharma_plot, ~ggsave(filename = .x, plot = .y, height = 11.5, width = 15, units = "in"))
walk2(assumption_checks_richness$plotname3, assumption_checks_richness$dharma_xvar_plot, ~ggsave(filename = .x, plot = .y, height = 11.5, width = 15, units = "in"))
```

**Extract results**
```{r step4d, message = FALSE}
#Will also add information about sample size: total # of observations (rows), number of levels per random effect, and the number of replicates (split into 'control' vs. 'treatment')
results_richness <- models_richness %>%
  mutate(summary = map(model, summary),
         summary_tidy = map(model, broom.mixed::tidy),
         confint_wald = map(model, ~calculate_ci(., method_name = "wald"))) %>%
  mutate(num_obs = map(model, get_number_obs),
         num_levels = map(model, get_number_re_levels),
         num_reps = map(data, ~get_sample_size(data = ., vars = c("year", "patch", "control_treatment"), grouping_var = "control_treatment")))

#Extract model summaries
results_tidy_richness <- results_richness %>%
  select(model_number, analysis, bird_groups, yvars, summary_tidy) %>%
  unnest(c(summary_tidy))

#Extract confidence intervals
results_confint_richness <- results_richness %>%
  select(model_number, analysis, bird_groups, yvars, confint_wald) %>%
  mutate(confint_df = map(confint_wald, as.data.frame)) %>% #CI as dataframe
  mutate(confint_df = map(confint_df, ~tibble::rownames_to_column(., var = "term"))) %>%
  unnest(cols = confint_df) %>%
  rename(lowerCI = "2.5 %", upperCI = "97.5 %") %>%
  select(-confint_wald, -Estimate)

#Back-transform coefficients and confidence intervals to data scale from model scale
results_tidy_confint_richness <- results_tidy_richness %>%
  left_join(results_confint_richness) %>%
  mutate_at(vars(estimate, lowerCI, upperCI), .funs = list(exp = ~ifelse(effect == "fixed", exp(.), NA))) %>% 
  mutate_at(vars(estimate, std.error, statistic, lowerCI, upperCI, estimate_exp, lowerCI_exp, upperCI_exp), ~round(., digits = 2)) %>%
  mutate(pvalue_round = format.pval(pv = p.value, digits = 2, eps = 0.001)) %>%
  select(model_number:term, estimate, lowerCI, upperCI, statistic, pvalue_round, pvalue = p.value, std_error = std.error, everything())

#Extract number of reps for each dataset
sample_size_richness <- results_richness %>%
  select(model_number, analysis, bird_groups, yvars, num_obs, num_reps) %>%
  unnest(cols = num_reps)  %>%
  mutate(num_obs = unlist(num_obs))
```

**Calculate estimated marginal means, control and treatment contrasts, and contrast of contrasts**
```{r step4e, message = FALSE}
#Calculate estimated means (for plots), pre-to-post contrasts (for written results interpretation), and contrast of contrasts (for plots)
emmeans_contrasts_richness <- results_richness %>%
  mutate(ggeffects = map(model, ~ggemmeans(., terms = c("exp_phase", "control_treatment"), back.transform = TRUE))) %>%
  mutate(emm = map(model, ~emmeans(., specs = ~exp_phase:control_treatment))) %>%
  mutate(emm_contrasts = map(emm, ~contrast(., method = "revpairwise", by = c("control_treatment"), type = "response"))) %>%
  mutate(emm_contrasts_x2 = map(emm, ~contrast(emmeans(., ~exp_phase:control_treatment), interaction = ("revpairwise"), type = "response")))
  
#Extract estimated marginal means 
emmeans_richness <- emmeans_contrasts_richness %>%
  select(model_number, analysis, bird_groups, yvars, ggeffects) %>% 
  unnest(cols = c(ggeffects))

#Extract contrasts (first need to convert into dataframe)
contrasts_richness <- emmeans_contrasts_richness %>%
  mutate(emm_contrasts = map(emm_contrasts, ~as.data.frame(summary(., infer = TRUE)))) %>%
  select(model_number, analysis, bird_groups, yvars, emm_contrasts) %>% 
  unnest(cols = c(emm_contrasts)) %>%
  select(model_number, analysis, bird_groups, yvars, contrast, control_treatment, ratio, lowerCI = lower.CL, upperCI = upper.CL, std_error = SE, everything()) %>%
  mutate_if(is.numeric, ~round(., digits = 2))

#Extract contrast of contrasts (first need to convert into dataframe)
contrasts_x2_richness <- emmeans_contrasts_richness %>%
  mutate(emm_contrasts_x2 = map(emm_contrasts_x2, ~as.data.frame(summary(., infer = TRUE)))) %>%
  select(model_number, analysis, bird_groups, yvars, emm_contrasts_x2) %>% 
  unnest(cols = c(emm_contrasts_x2)) %>%
  select(model_number, analysis, bird_groups, yvars, contains("revpairwise"), ratio, lowerCI = lower.CL, upperCI = upper.CL, std_error = SE, everything()) %>%
  mutate_if(is.numeric, ~round(., digits = 2))
```

**Plot results**

Interaction plots
```{r step4f, message = FALSE, fig.width=9, fig.height=9}
interaction_plots_richness <- emmeans_contrasts_richness %>%
  mutate(interaction_plot = pmap(list(ggeffects, yvars), ~make_interaction_plot(ggeffects_df = ..1, yvar = ..2, ymax = 4)))

#Make multiplot (ALL SPECIES + GREH/VISA)
interaction_plots_richness <- interaction_plots_richness %>%
  arrange(yvars, analysis)

interaction_multiplot_richness <- ggarrange(plotlist = interaction_plots_richness$interaction_plot, nrow = 2, ncol = 2, common.legend = TRUE, legend = "bottom")
interaction_multiplot_richness
```

Contrast plot
```{r step4g, message = FALSE, fig.width=6, fig.height=6}
contrast_plot_richness <- contrasts_x2_richness %>%
  mutate(analysis = factor(analysis, levels = c("pollen_all_birds", "pollen_recaps"), labels = c("# morphotypes\n(all birds)", "# morphotypes\n(recaptures only)"))) %>%
  make_contrast_plot(estimate_name = "ratio", xaxis_name = "analysis", shading = "above") +
  scale_y_continuous(limits = c(0, 4), breaks = c(0, 0.5, 1, 2, 3, 4)) +
  coord_cartesian(ylim = c(0, 4), xlim = c(1, 2), clip = "off")

contrast_plot_richness
```

## Step 5: Make figure summarizing all of analyses above, with contrast for interaction term
```{r step5, message = FALSE, fig.width = 9, fig.height = 12}
#Contrast plot (POLLEN, NETWORK-LEVEL)
contrast_plot_pollen_network <- contrasts_x2_network %>%
  filter(analysis == "pollen" & yvars == "H2") %>%
  make_contrast_plot(estimate_name = "odds.ratio", xaxis_name = "yvars", shading = "below") +
  scale_x_discrete(labels = c(h2_label)) +
  scale_y_continuous(limits = c(0, 4), breaks = c(0, 0.5, 1, 2, 3, 4)) +
  coord_cartesian(ylim = c(0, 4), xlim = c(1, 1), clip = "off") +
  theme(legend.position = "none")

#Contrast plot (VISITATION, NETWORK-LEVEL)
contrast_plot_visitation_network <- contrasts_x2_network %>%
  filter(analysis == "visitation" & yvars == "H2") %>%
  make_contrast_plot(estimate_name = "odds.ratio", xaxis_name = "yvars", shading = "below") +
  scale_x_discrete(labels = c(h2_label)) +
  scale_y_continuous(limits = c(0, 4), breaks = c(0, 0.5, 1, 2, 3, 4)) +
  coord_cartesian(ylim = c(0, 4), xlim = c(1, 1), clip = "off") +
  theme(legend.position = "none")

#Contrast plot (POLLEN, SPECIES-LEVEL)
contrast_plot_pollen_species <- contrasts_x2_network %>%
  filter(analysis == "pollen" & (yvars == "d" | yvars == "species.specificity.index")) %>%
  make_contrast_plot(estimate_name = "odds.ratio", xaxis_name = "yvars", shading = "below") +
  scale_x_discrete(labels = c(d_label, ssi_label)) +
  scale_y_continuous(limits = c(0, 6), breaks = c(0, 0.5, 1, 2, 3, 4, 5, 6)) +
  coord_cartesian(ylim = c(0, 6), xlim = c(1, 2), clip = "off")

#Contrast plot (VISITATION, SPECIES-LEVEL)
contrast_plot_visitation_species <- contrasts_x2_network %>%
  filter(analysis == "visitation" & (yvars == "d" | yvars == "species.specificity.index")) %>%
  make_contrast_plot(estimate_name = "odds.ratio", xaxis_name = "yvars", shading = "below") +
  scale_x_discrete(labels = c(d_label, ssi_label)) +
  scale_y_continuous(limits = c(0, 6), breaks = c(0, 0.5, 1, 2, 3, 4, 5, 6)) +
  coord_cartesian(ylim = c(0, 6), xlim = c(1, 2), clip = "off")

#Combine...
contrast_multiplot_all_analyses <- ggarrange(contrast_plot_pollen_network, contrast_plot_visitation_network, contrast_plot_pollen_species, contrast_plot_visitation_species, contrast_plot_richness, common.legend = TRUE, ncol = 2, nrow = 3, legend = "bottom")
contrast_multiplot_all_analyses
```

## Step 6: Export results 
```{r step6, message = FALSE, warning = FALSE}
#Summary tables (NETWORK METRICS)
write.csv(results_tidy_confint_network, "../results/analyses_experiment/tables/Network_results_summary_tables.csv")
write.csv(sample_size_network, "../results/analyses_experiment/tables/Network_results_sample_size_summary.csv")
write.csv(emmeans_network, "../results/analyses_experiment/tables/Network_results_emmeans.csv")
write.csv(contrasts_network, "../results/analyses_experiment/tables/Network_results_contrasts.csv")
write.csv(contrasts_x2_network, "../results/analyses_experiment/tables/Network_results_contrast_of_contrasts.csv")

#Plots (NETWORK METRICS)
ggsave("../results/analyses_experiment/figures/Interaction_multiplot_network_all_species.png", interaction_multiplot_network_all, dpi = 300, units = "in", width = 9, height = 12, bg = "white")
ggsave("../results/analyses_experiment/figures/Interaction_multiplot_network_greh_visa.png", interaction_multiplot_network_gv, dpi = 300, units = "in", width = 9, height = 9, bg = "white")
ggsave("../results/analyses_experiment/figures/Contrast_multiplot_network.png", contrast_multiplot_network, dpi = 300, units = "in", width = 13, height = 5, bg = "white")

#Summary tables (INDIVIDUAL SPECIALIZATION)
write.csv(results_tidy_confint_richness, "../results/analyses_experiment/tables/Individual_results_summary_tables.csv")
write.csv(sample_size_richness, "../results/analyses_experiment/tables/Individual_results_sample_size_summary.csv")
write.csv(emmeans_richness, "../results/analyses_experiment/tables/Individual_results_emmeans.csv")
write.csv(contrasts_richness, "../results/analyses_experiment/tables/Individual_results_contrasts.csv")
write.csv(contrasts_x2_richness, "../results/analyses_experiment/tables/Individual_results_contrast_of_contrasts.csv")

#Plots (INDIVIDUAL SPECIALIZATION)
ggsave("../results/analyses_experiment/figures/Interaction_multiplot_individual.png", interaction_multiplot_richness, dpi = 300, units = "in", width = 9, height = 9, bg = "white")

#Plots (NETWORK METRICS + INDIVIDUAL SPECIALIZATION)
ggsave("../results/analyses_experiment/figures/Contrast_multiplot_all_analyses.png", contrast_multiplot_all_analyses, dpi = 300, units = "in", width = 9, height = 12, bg = "white")
```